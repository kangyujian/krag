# 文本嵌入可扩展方案（用于入库与检索）

本文档给出一套可落地的“文本嵌入（Embedding）”扩展方案，满足入库阶段的批量向量化与查询阶段的向量检索需求，并支持多租户隔离与按需切换不同模型供应商。

## 1. 目标与原则
- 可插拔：通过统一抽象与工厂创建不同嵌入实现，业务无感切换。
- 多租户隔离：按 `tenantId/kbId` 配置不同模型、参数与维度。
- 高效稳健：批量嵌入、并发控制、重试与限流，保证稳定性与吞吐。
- 一致抽象：入库与检索统一依赖 `EmbeddingModel`，降低耦合。

## 2. 核心接口与配置（krag-core）
```java
public interface EmbeddingModel {
    String id();
    int dimension();
    float[] embed(String text);
    List<float[]> embedBatch(List<String> texts);
}

public interface EmbeddingProvider {
    String provider(); // gte/bge/openai/qwen/local...
    EmbeddingModel create(EmbeddingConfig config);
}

public class EmbeddingConfig {
    public String provider;             // 供应商标识
    public String modelId;              // 具体模型 ID
    public Integer dimension;           // 可选覆盖维度
    public Map<String, String> params;  // apiKey/endpoint/timeout/rateLimit 等
}
```

## 3. 业务扩展机制（Spring Bean）
- 在 `krag-embedding` 中为每个供应商实现 `EmbeddingProvider` 与 `EmbeddingModel`。
- 通过 Spring 容器注册 Provider：使用 `@Component("vendorX")` 或在 `@Configuration` 中显式定义 Bean。
- 运行时按 `provider` 从 `Map<String, EmbeddingProvider>` 或 `EmbeddingProviderRegistry` 选择对应 Provider，并创建模型实例。

示例（基于 Spring 注入 Map）：
```java
@Component("gte")
public class GteEmbeddingProvider implements EmbeddingProvider {
    @Override public String provider() { return "gte"; }
    @Override public EmbeddingModel create(EmbeddingConfig cfg) { /* ... */ }
}

@Component
public class EmbeddingProviderRegistry {
    private final Map<String, EmbeddingProvider> providers;
    public EmbeddingProviderRegistry(Map<String, EmbeddingProvider> providers) {
        this.providers = providers;
    }
    public EmbeddingModel resolve(EmbeddingConfig cfg) {
        EmbeddingProvider p = Optional.ofNullable(providers.get(cfg.provider))
            .orElseThrow(() -> new IllegalArgumentException("No provider: " + cfg.provider));
        return p.create(cfg);
    }
}
```

## 4. 模型注册与多租户配置（ModelRegistry）
`ModelRegistry` 负责解析 `tenantId/kbId` → `EmbeddingConfig`；支持全局默认、租户级与知识库级覆盖。

`application.yml` 示例：
```yaml
krag:
  embedding:
    default:
      provider: gte
      modelId: gte-base-zh
      dimension: 768
      params:
        endpoint: https://api.example.com/embed
        apiKey: ${EMBED_API_KEY}
        timeoutMs: "5000"
    tenants:
      t1:
        provider: local
        modelId: bge-small-local
        dimension: 512
      t2:
        kb:
          kb1:
            provider: openai
            modelId: text-embedding-3-small
            dimension: 1536
            params:
              apiKey: ${OPENAI_API_KEY}
              endpoint: https://api.openai.com/v1
```

## 5. 入库流程集成
- 流程：解析 → 分块 → `embedBatch` → 归一化 → `VectorStore.upsert`。
- 并发：对分块批量嵌入（如批大小 32/64），线程池控制；对远程服务设置速率上限。
- 归一化：使用 `L2 normalize`（若检索采用余弦相似度）。
- 校验：统一维度，发现不一致即拒绝入库并记录。
- 重试与降级：对 429/5xx 执行指数退避重试；不可用时切换到本地模型（若配置）。

伪代码：
```java
List<String> chunks = chunker.chunk(texts, maxChars);
EmbeddingModel model = registry.resolve(tenantId, kbId);
List<float[]> vecs = model.embedBatch(chunks);
vecs = vecs.stream().map(this::l2Normalize).toList();
store.upsert(tenantId, kbId, toVectorRecords(docId, chunks, vecs));
```

## 6. 相似度与维度策略
- 向量库维度：按 `EmbeddingModel.dimension()` 配置库或集合（内存库校验一致性）。
- 相似度：默认 `cosine`；若使用 `dot-product` 则可不进行 L2 归一化或进行缩放。
- 混合维度：同一 `kbId` 内建议保持同一维度，避免检索复杂度与转化成本。

## 7. 限流、重试与降级
- 限流：对远程嵌入服务设置并发与速率上限（如令牌桶）。
- 重试：对 429/5xx 错误使用指数退避重试（上限 N 次）。
- 降级：远程不可用时可切换到本地模型（若配置了 `fallbackProvider`）。

## 8. 缓存与去重
- 片段缓存：对相同文本（哈希后）缓存嵌入结果（LRU + TTL），减少重复计算。
- 去重：分块后做内容归并，提升缓存命中率与存储效率。

## 9. 安全与成本管理
- 密钥管理：通过环境变量或密钥管理服务注入 `apiKey`，不写入日志与仓库。
- 成本监控：按租户统计嵌入调用次数与字数，设定配额与告警阈值。

## 10. 测试与观测
- 单元测试：维度一致性、批量接口、预处理与归一化。
- 集成测试：入库流程（解析→嵌入→入库），模拟限流与超时场景。
- 端到端：多租户不同模型配置的入库与查询闭环验证。
- 观测：导出耗时、失败率、QPS、重试次数等指标到日志/监控。

## 11. Prompt 嵌入与生成（可选增强）
- 组合策略：
  - A：合并 `system`/`user`/`contexts` 后整体嵌入；
  - B：分段嵌入后按权重合成（推荐，默认权重 `system=0.2/user=0.6/context=0.2`）。
- 作用范围：查询阶段用于生成的特征融合，不直接参与向量库检索（检索仍使用查询文本的嵌入）。

## 12. 新增嵌入实现的步骤
1) 在 `krag-embedding` 新增 `vendorX` 包，提供 `EmbeddingProvider` 与 `EmbeddingModel` 实现。
2) 在 Spring 容器注册 Provider（`@Component("vendorX")` 或 `@Bean`）。
3) 在 `application.yml` 配置 `provider: vendorX` 与模型参数。
4) 编写测试（维度、批量、异常场景）并跑入库集成测试。

---

该方案在不改动业务层的前提下，通过配置与插件化实现嵌入能力的可扩展与可切换，满足性能、稳定性与多租户隔离需求。